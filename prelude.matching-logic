--- Specification modules
-------------------------

--- `spec` modules allow defining signatures and theories.

spec definedness

--- The `metavar` declaration allows defining variables used in axioms and notation.
    metavar ph0 ph1 : Pattern .
    metavar x : EVar .
    metavar X : SVar .

--- `notation` allows us to define sugars.
--- We will need several well-formedness checks here.
---
--- 1.  Each notation has a unique definition
--- 2.  LHS is either an atom, or an s-expression of the form `(atom metavar*)`
--- 3.  All metavariables in the RHS are either present on the LHS
---     or they are bound variables disjoint from other metavariables

    notation top := ( not bot ) .
    notation (iff ph0 ph1) := (and (imp ph0 ph1) (imp ph1 ph0)) .
    notation (forall x ph0) := (not (exists x (not ph0))) .

--- `notation` may also have "when" clauses, allowing us to specify side conditions.
--- The consensus right now is that we want to allow side conditions that
--- are meta-conditions, such as positivity, freshness, etc.
--- We need to consider whether we want to allow side conditions that are
--- general patterns, such as that a pattern is a predicate, or functional.
    notation (nu X ph0)
        when < positive     X   in ph0 >
             < substitution ph1 is ph0[ (not X) / X ] >
          := (not (mu X (not ph1))) .

--- `symbol` allows us to specify a signature.
--- We do not currently allow specifying arity and sorts associated with a
--- symbol, but its something we'll want to consider.
    symbol definedness .
    notation (ceil ph0) := (app definedness ph0) .
    axiom definedness: (ceil x) .

    notation (foo ph0) := (bar ph0 ) .
    notation (foo ph0) := (buzz ph0 ) .
    notation (kleene ph0) := (mu X (or epsilon (concat X ph0))) .

    notation (floor ph0) := (not (ceil (not ph0))) .
    notation (in x ph0) := (ceil (and x ph0)) .
    notation (included ph0 ph1) := (floor (imp ph0 ph1)) .
    notation (eq ph0 ph1) := (floor (iff ph0 ph1)) .
endspec

--- `prop` modules may import specifications, but cannot declare new axioms or
--- extend the signature.
props definedness-lemmas
    import definedness
    theorem foo : (imp buzz bar) .
    theorem bar : (imp buzz bar) .
    theorem buzz : (imp buzz bar) .
    theorem buz
       when (imp buz bar)
          : (imp buz buz)
endprops

--- `prop` modules may import specifications, but cannot declare new axioms or
--- extend the signature.
props definedness-lemmas
    import definedness
--- theorem <name> : <pattern>   := <proof-source>  $ <proof-hint> $

--- Use the translation of a proof done using the Coq formalization.
    theorem foo : (imp buzz bar) := coq $ my-foo $ .

--- Use the translation of a proof done using the Lean formalization.
    theorem bar : (imp buzz bar) := lean $ bar $ .

--- Use a propositional logic decision procedure for proving the following:
    theorem buz
       when (imp buz bar)
            -------------
          : (imp buz buz)
         := lookup $ buzz $ .
    theorem blu : (imp phi phi)  := propositional $ $ .
endprops

spec sorts
    imports definedness .

    symbol sort .
    // TODO: Sort isn't declared as a sort. I'm not sure if that was intentional?

    symbol inhabitant .
    notation (inh ph0) := (app inhabitant ph0) .
    notation (in-sort ph0 ph1) := (included ph0 (inh ph1)) .

    axiom inh-sort-nonempty : (exists x (in-sort x sort)) .

    notation (sorted-forall x ph0 ph1)
          := (forall x (imp (in-sort x ph0) ph1)) .
    notation (sorted-exists x ph0 ph1)
          := (exists x (and (in-sort x ph0) ph1)) .

    metavar s0 s1 s2 s3 : EVar .
    notation (forall-sort s0 ph0)
          := (sorted-forall s0 sort ph0 ) .
    notation (exists-sort s0 ph0)
          := (sorted-exists s0 sort ph0 ) .
endspec

spec special-patterns
    imports definedness .

    // TODO: I'd prefer to default to requiring disjointness/freshness for notation/axioms,
    //       and assuming not-disjointness for theorems.
    // This means that if there is an error wrt disjointness, you will be able to prove *fewer* things.
    notation (is-singleton ph0)
        when < disjoint x from ph0 >
          := (exists x (eq x ph0)) .

    notation (is-top ph0)       := (eq ph0 top) .
    notation (is-bot ph0)       := (eq ph0 bot) .
    notation (is-predicate ph0) := (or (is-top ph0) (is-bot ph0)) .
endspec

spec sorted-functions
    // TODO: Consider meta-notation for declaring functions.
    imports sorts .
    notation (is-constant ph0 ph1)
        when < disjoint x from ph0 >
             < disjoint x from ph1 >
          := (sorted-exists x ph1 (eq ph0 x)) .
    notation (is-unary-function ph0 ph1 ph2)
        when < disjoint x y from ph0 >
             < disjoint x y from ph1 >
             < disjoint x y from ph2 >
          := (sorted-forall x ph1 (sorted-exists y ph2 (eq (app ph0 x) y))) .
    notation (is-binary-function ph0 ph1 ph2 ph3)
        when < disjoint x y z from ph0 >
             < disjoint x y z from ph1 >
             < disjoint x y z from ph2 >
             < disjoint x y z from ph3 >
          := (sorted-forall x ph1 (sorted-exists y ph2 (eq (app ph0 x) y))) .
endspec

spec unit
    imports sorted-functions .
    symbol unit-sort .
    axiom unit-sort-is-sort : (exists-sort x (eq x unit-sort)) .

    symbol unit .
    axiom unit-is-singleton: (is-singleton unit) .
    axiom unit-sort : (eq unit (inh unit-sort)) .
endspec

spec pair
    imports sorted-functions .

    symbol pair-sort-symbol .
    axiom pair-sort-is-sort: (is-binary-function pair-sort-symbol sort sort sort) .
    notation (pair-sort ph0 ph1) := (app (app pair-sort-symbol ph0) ph1) .

    symbol pair-symbol .
    axiom pair-symbol-is-binary-function:
      (forall-sort s0 (forall-sort s1 (is-binary-function pair-symbol s0 s1 (pair-sort s0 s1)))) .
    notation (pair ph0 ph1) := (app (app pair-symbol ph0) ph1) .

    symbol pair-fst .
    axiom pair-fst-symbol-is-unary-function:
        (forall-sort s0 (forall-sort s1 (is-unary-function pair-fst-symbol (pair-sort s0 s1) s0))) .
    notation pair-fst := (app pair-fst-symbol ph0 ) .

    symbol pair-snd .
    axiom pair-snd-symbol-is-unary-function:
        (forall-sort s0 (forall-sort s1 (is-unary-function pair-snd-symbol (pair-sort s0 s1) s0))) .
    notation pair-snd := (app pair-snd-symbol ph0 ) .

    axiom pair-fst : (forall-sort s0 (forall-sort s1
                       (sorted-forall x0 s0 (sorted-forall x1 s2
                          (eq (pair-fst (pair x1 x2)) x1))))) .
    axiom pair-snd : (forall-sort s0 (forall-sort s1
                       (sorted-forall x0 s0 (sorted-forall x1 s2
                           (eq (pair-snd (pair x1 x2)) x2))))) .
    axiom pair-inj : (forall-sort s0 (forall-sort s1
                        (sorted-forall x0 s0 (sorted-forall x1 s2
                        (sorted-forall x2 s0 (sorted-forall x3 s2
                             (imp (eq (pair x0 x1) (pair x2 x3))
                                (and (eq x0 x2) (eq x1 x3))))))))) .
endspec
